# Dokumentacja Systemu Elektronicznego Programowania z Interfejsem Wielomodalnym

## 1. Opis ogólny systemu

System Elektronicznego Programowania z Interfejsem Wielomodalnym (SEPIW) to zintegrowane środowisko deweloperskie, które umożliwia autonomiczne przyjmowanie i realizację zadań programistycznych z wykorzystaniem interfejsów głosowych, wideo i tekstowych. System operuje lokalnie, wykorzystując Ollama jako silnik LLM oraz lokalne instancje GitLab do zarządzania kodem, przy jednoczesnej komunikacji z użytkownikiem za pośrednictwem platformy Rocket.Chat rozszerzonej o funkcje wideo.

### 1.1. Cele systemu

- Przyjmowanie zadań programistycznych przez kanały głosowe, tekstowe i wideo
- Automatyzacja procesu programowania z wykorzystaniem lokalnego LLM
- Autonomiczne wykonywanie zadań w środowisku GitLab
- Interaktywna, wielomodalna komunikacja z użytkownikami
- Automatyzacja pracy z przeglądarką internetową i narzędziami programistycznymi
- Zarządzanie uwierzytelnianiem z różnymi metodami 2FA
- Prezentacja postępów pracy w czasie rzeczywistym przez kanały głosowe i wideo

## 2. Architektura systemu

### 2.1. Komponenty systemu

#### 2.1.1. Warstwa komunikacji
- **Rocket.Chat**: Centralna platforma komunikacji obsługująca:
  - Czat tekstowy
  - Rozmowy głosowe
  - Transmisje wideo
  - Integracje z systemami zewnętrznymi

#### 2.1.2. Warstwa sztucznej inteligencji
- **Ollama**: Lokalny silnik LLM odpowiedzialny za:
  - Rozumienie zapytań i poleceń
  - Generowanie kodu
  - Planowanie zadań programistycznych
  - Podejmowanie decyzji w procesie automatyzacji

#### 2.1.3. Warstwa kontroli i automatyzacji
- **PyAutoGUI/Selenium**: Biblioteki do automatyzacji GUI umożliwiające:
  - Sterowanie przeglądarką
  - Interakcje z VS Code w wersji przeglądarkowej
  - Obsługę narzędzi deweloperskich (Windsurf, Cursor)
  - Automatyzację procesów uwierzytelniania

#### 2.1.4. Warstwa deweloperska
- **GitLab CE**: Lokalny system zarządzania kodem źródłowym zapewniający:
  - Repozytorium Git
  - CI/CD pipeline
  - Issue tracking
  - Zarządzanie projektami

- **VS Code Web**: Przeglądarkowa wersja edytora kodu wraz z wtyczkami:
  - Windsurf
  - Cursor
  - Continue

#### 2.1.5. Warstwa rozpoznawania i syntezy mowy/obrazu
- **Vosk/Whisper**: Lokalne STT (Speech-to-Text) do rozpoznawania mowy
- **Mozilla TTS/Coqui**: Lokalne TTS (Text-to-Speech) do syntezy mowy
- **Computer Vision (np. OpenCV)**: Narzędzia do analizy obrazu

### 2.2. Schemat architektury

```
┌─────────────────────────────────────────────────────────────────┐
│                      Interfejs Użytkownika                       │
│  ┌───────────────┐   ┌───────────────┐   ┌───────────────────┐  │
│  │  Chat Tekstowy│   │  Chat Głosowy │   │  Transmisja Wideo │  │
│  └───────┬───────┘   └───────┬───────┘   └─────────┬─────────┘  │
└──────────┼───────────────────┼───────────────────┬─┘            │
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                         Rocket.Chat                            ││
│               (z rozszerzeniami wideo/audio)                   ││
└──────────┬───────────────────┬───────────────────┬─────────────┘│
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                      Moduł Middleware                          ││
│     (Obsługa komunikacji między komponentami systemu)          ││
└──────────┬───────────────────┬───────────────────┬─────────────┘│
           │                   │                   │              │
┌──────────▼──────┐  ┌─────────▼─────────┐ ┌───────▼────────────┐ │
│  Ollama (LLM)   │  │ Moduł Automatyzacji│ │  GitLab CE         │ │
│                 │  │ (PyAutoGUI/Selenium)│ │ (zarządzanie kodem)│ │
└──────────┬──────┘  └─────────┬─────────┘ └───────┬────────────┘ │
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                                                               ││
│                     VS Code Web + Wtyczki                      ││
│                (Windsurf, Cursor, Continue)                    ││
│                                                               ││
└───────────────────────────────────────────────────────────────┘│
```

## 3. Komponenty i technologie

### 3.1. Ollama (Lokalny LLM)

Ollama działa jako lokalny silnik sztucznej inteligencji, obsługujący analizę języka naturalnego, generowanie kodu oraz planowanie zadań programistycznych. W zależności od dostępnych zasobów sprzętowych, system wykorzystuje różne modele:

- Dla maszyn z ograniczonymi zasobami (8-16GB RAM): 
  - Modele 3B-7B parametrów (np. Llama 3.1 7B)
  - Kwantyzacja 4-bitowa dla optymalizacji pamięci

- Dla maszyn z lepszymi zasobami (32GB+ RAM, GPU):
  - Modele 13B-34B parametrów (np. CodeLlama 34B)
  - Wsparcie dla wielomodalności (tekst + obraz)

#### 3.1.1. Integracja z automatyzacją przeglądarki

Ollama komunikuje się z modułem automatyzacji przeglądarki poprzez lokalny serwer API, wysyłając instrukcje dotyczące:
- Nawigacji stron
- Wypełniania formularzy
- Interakcji z elementami UI
- Interpretacji zawartości ekranu

### 3.2. Rocket.Chat z rozszerzeniami wideo

Rocket.Chat służy jako główna platforma komunikacyjna, rozszerzona o możliwości wideo i głosowe:

#### 3.2.1. Konfiguracja dla transmisji wideo
```yaml
# Fragment konfiguracji docker-compose.yml dla Rocket.Chat z WebRTC
services:
  rocketchat:
    image: rocketchat/rocket.chat:latest
    ports:
      - "3000:3000"
    environment:
      # Podstawowa konfiguracja
      - PORT=3000
      - ROOT_URL=http://localhost:3000
      - MONGO_URL=mongodb://mongo:27017/rocketchat
      - MONGO_OPLOG_URL=mongodb://mongo:27017/local
      # Konfiguracja WebRTC
      - ENABLE_WEBRTC=true
      - WEBRTC_MEDIA_SERVERS=turn:turn.example.com:3478
      - WEBRTC_ENABLE_SCREEN_SHARING=true
      - WEBRTC_ENABLE_CHANNEL=true
    depends_on:
      - mongo
    volumes:
      - ./uploads:/app/uploads
    restart: unless-stopped
```

#### 3.2.2. Integracja Rocket.Chat z GitLab

Rocket.Chat integruje się z lokalnym GitLab za pomocą webhooków, umożliwiając automatyczne powiadomienia o:
- Nowych commitach
- Otwartych pull requestach
- Wynikach CI/CD pipeline
- Zamkniętych zadaniach

### 3.3. Moduł automatyzacji przeglądarki

System wykorzystuje zaawansowane biblioteki do automatyzacji GUI w celu sterowania przeglądarką i narzędziami programistycznymi:

#### 3.3.1. PyAutoGUI

Służy do sterowania niskiego poziomu, takiego jak:
- Poruszanie kursorem myszy
- Klikanie elementów
- Wprowadzanie tekstu z klawiatury
- Wykonywanie zrzutów ekranu do analizy

#### 3.3.2. Selenium/Playwright

Zapewnia wysokopoziomowe sterowanie przeglądarką:
- Nawigacja pomiędzy stronami
- Identyfikacja elementów DOM
- Wypełnianie formularzy
- Obsługa dynamicznego JavaScript

#### 3.3.3. Przykładowy kod automatyzacji

```python
# Przykład automatyzacji logowania z 2FA przez moduł automatyzacji
import pyautogui
import time
from selenium import webdriver
from selenium.webdriver.common.by import By

# Klasa do obsługi 2FA
class TwoFactorAuthHandler:
    def __init__(self, email_client, sms_client):
        self.email_client = email_client
        self.sms_client = sms_client
        
    def get_code_from_email(self, email_subject):
        """Pobierz kod 2FA z najnowszej wiadomości email o danym temacie"""
        emails = self.email_client.fetch_emails(subject=email_subject, unread_only=True)
        if emails:
            # Ekstrakcja kodu 2FA z treści email
            code = self.email_client.extract_2fa_code(emails[0])
            return code
        return None
        
    def get_code_from_sms(self):
        """Pobierz kod 2FA z najnowszego SMS"""
        messages = self.sms_client.fetch_recent_messages(limit=1)
        if messages:
            # Ekstrakcja kodu 2FA z treści SMS
            code = self.sms_client.extract_2fa_code(messages[0])
            return code
        return None

# Przykład użycia w procesie logowania
def login_with_2fa(url, username, password, auth_handler):
    driver = webdriver.Chrome()
    driver.get(url)
    
    # Logowanie podstawowe
    driver.find_element(By.ID, "username").send_keys(username)
    driver.find_element(By.ID, "password").send_keys(password)
    driver.find_element(By.ID, "login-button").click()
    
    # Obsługa 2FA
    # Sprawdź, który rodzaj 2FA jest wymagany
    if "Enter the code sent to your email" in driver.page_source:
        code = auth_handler.get_code_from_email("Your verification code")
    elif "Enter the code sent to your phone" in driver.page_source:
        code = auth_handler.get_code_from_sms()
    else:
        # Obsługa aplikacji 2FA (np. Google Authenticator)
        # Tutaj możemy użyć PyAutoGUI do odczytania kodu z aplikacji
        pyautogui.hotkey('alt', 'tab')  # Przełącz do aplikacji 2FA
        time.sleep(1)
        screenshot = pyautogui.screenshot(region=(100, 200, 200, 100))  # Zrzut obszaru z kodem
        code = extract_code_from_image(screenshot)  # Funkcja OCR do ekstrakcji kodu
        pyautogui.hotkey('alt', 'tab')  # Powrót do przeglądarki
    
    # Wprowadź kod 2FA
    driver.find_element(By.ID, "verification-code").send_keys(code)
    driver.find_element(By.ID, "verify-button").click()
    
    return driver  # Zwróć zalogowaną sesję przeglądarki
```

### 3.4. GitLab CE

GitLab Community Edition działa jako lokalny system zarządzania projektami programistycznymi, oferując:

#### 3.4.1. Konfiguracja GitLab

```yaml
# Fragment konfiguracji docker-compose.yml dla GitLab
services:
  gitlab:
    image: gitlab/gitlab-ce:latest
    ports:
      - "8080:80"
      - "8022:22"
    volumes:
      - gitlab_config:/etc/gitlab
      - gitlab_logs:/var/log/gitlab
      - gitlab_data:/var/opt/gitlab
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        external_url 'http://localhost:8080'
        gitlab_rails['gitlab_shell_ssh_port'] = 8022
        gitlab_rails['time_zone'] = 'Europe/Warsaw'
        # Konfiguracja do integracji z Rocket.Chat
        gitlab_rails['webhooks_enabled'] = true
        gitlab_rails['webhook_timeout'] = 10
    restart: unless-stopped
  
  # GitLab Runner dla CI/CD
  gitlab-runner:
    image: gitlab/gitlab-runner:latest
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - gitlab_runner_config:/etc/gitlab-runner
    restart: unless-stopped
```

#### 3.4.2. Automatyzacja GitLab przez API

System komunikuje się z GitLab poprzez jego API REST, wykonując operacje takie jak:
- Tworzenie nowych projektów
- Tworzenie i zamykanie issues
- Wykonywanie commitów i merge requestów
- Uruchamianie i monitorowanie pipeline'ów CI/CD

### 3.5. VS Code Web z wtyczkami

System wykorzystuje VS Code w wersji przeglądarkowej jako główne środowisko programistyczne, wraz z zaawansowanymi wtyczkami AI:

#### 3.5.1. Windsurf
Wtyczka integrująca się z lokalnym LLM (Ollama) do asystowania przy tworzeniu kodu, oferująca:
- Generowanie kodu na podstawie opisu
- Uzupełnianie kodu
- Debugowanie i ulepszanie istniejącego kodu

#### 3.5.2. Cursor
Zaawansowane narzędzie z integracją AI do edycji kodu, umożliwiające:
- Refaktoryzację kodu
- Dokumentowanie funkcji
- Automatyczne testowanie

#### 3.5.3. Continue
Wtyczka do VS Code umożliwiająca ciągłą asystę AI podczas programowania:
- Sugestie dokończenia kodu
- Wyjaśnienia działania kodu
- Generowanie testów jednostkowych

### 3.6. Rozpoznawanie i synteza mowy

#### 3.6.1. Vosk/Whisper (STT)

Lokalne modele Vosk lub Whisper umożliwiają rozpoznawanie mowy bez konieczności wysyłania danych do zewnętrznych usług. Konfiguracja w Docker Compose:

```yaml
# Fragment konfiguracji docker-compose.yml dla usługi STT
services:
  # STT - Vosk dla maszyn z ograniczonymi zasobami
  vosk:
    image: alphacep/kaldi-vosk-server:latest
    ports:
      - "2700:2700"
    volumes:
      - ./vosk-models:/opt/vosk-model
    restart: unless-stopped
    
  # LUB Whisper dla maszyn z lepszymi zasobami
  whisper:
    image: onerahmet/openai-whisper-asr-webservice:latest
    ports:
      - "9000:9000"
    volumes:
      - ./whisper-data:/data
    environment:
      - ASR_MODEL=medium
      - ASR_ENGINE=whisper
    restart: unless-stopped
```

#### 3.6.2. Mozilla TTS/Coqui (TTS)

Lokalne modele syntezy mowy do generowania komunikatów głosowych:

```yaml
# Fragment konfiguracji docker-compose.yml dla usługi TTS
services:
  # TTS - Mozilla TTS dla maszyn z ograniczonymi zasobami
  mozilla-tts:
    image: synesthesiam/mozilla-tts:latest
    ports:
      - "5002:5002"
    restart: unless-stopped
    
  # LUB Coqui TTS dla maszyn z lepszymi zasobami
  coqui-tts:
    image: synesthesiam/coqui-tts:latest
    ports:
      - "5002:5002"
    volumes:
      - ./tts-models:/app/voices
    restart: unless-stopped
```

## 4. Przepływy pracy (Workflows)

### 4.1. Przyjmowanie zadania

1. Użytkownik przesyła zadanie przez:
   - Wiadomość email
   - Wiadomość na Rocket.Chat (tekst, głos, wideo)
   - Issue w GitLab

2. System przetwarza komunikat:
   - Dla wiadomości tekstowych: bezpośrednia analiza przez Ollama
   - Dla wiadomości głosowych: konwersja na tekst przez Vosk/Whisper, następnie analiza przez Ollama
   - Dla wiadomości wideo: ekstrakcja ścieżki audio, konwersja na tekst, analiza przez Ollama

3. Ollama analizuje treść zadania i tworzy:
   - Strukturę projektu
   - Listę zadań (issues) w GitLab
   - Plan implementacji

### 4.2. Realizacja zadania programistycznego

1. System inicjuje środowisko programistyczne:
   - Tworzy repozytorium w GitLab
   - Konfiguruje VS Code Web
   - Przygotowuje pliki bazowe projektu

2. Przepływ pracy programistycznej:
   - Ollama generuje kod za pomocą wtyczek VS Code (Windsurf, Cursor, Continue)
   - Moduł automatyzacji przeglądarki obsługuje VS Code Web
   - System commituje zmiany do GitLab
   - CI/CD pipeline sprawdza jakość kodu i uruchamia testy

3. Obsługa problemów:
   - Jeśli testy nie przechodzą, Ollama analizuje błędy i proponuje poprawki
   - System poprawia kod i ponownie commituje zmiany
   - Proces powtarza się do momentu pozytywnego zakończenia testów

### 4.3. Komunikacja postępów

1. System regularnie raportuje postępy:
   - Generuje wiadomości tekstowe o statusie zadań
   - Przygotowuje komunikaty głosowe za pomocą TTS
   - Nagrywa transmisje wideo pokazujące pracę w VS Code

2. Zautomatyzowane demonstracje:
   - System uruchamia przeglądarkę i pokazuje działanie zaimplementowanych funkcji
   - Nagrania są dostępne w Rocket.Chat

3. Interaktywna sesja Q&A:
   - Użytkownik może zadawać pytania o postęp prac
   - Ollama generuje odpowiedzi, które system przekazuje przez tekst lub głos
   - W razie potrzeby system demonstruje funkcjonalność przez transmisję wideo

### 4.4. Diagram przepływu pracy

```
┌─────────────────────┐
│ Otrzymanie zadania  │
│  (email/chat/głos)  │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│   Analiza zadania   │
│   przez Ollama LLM  │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│  Utworzenie issues  │
│     w GitLab        │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│  Generowanie kodu   │◄─────┐
│  przez Ollama + VS  │      │
│  Code Web + wtyczki │      │
└──────────┬──────────┘      │
           │                 │
┌──────────▼──────────┐      │
│  Commit do GitLab   │      │
│  i uruchomienie CI  │      │
└──────────┬──────────┘      │
           │                 │
┌──────────▼──────────┐      │
│    Analiza wyników  │      │
│       testów        │      │
└──────────┬──────────┘      │
           │                 │
┌──────────▼──────────┐      │
│    Testy przeszły?  │──Nie─┘
└──────────┬──────────┘
          Tak
           │
┌──────────▼──────────┐
│  Raportowanie       │
│  postępów (tekst/   │
│  głos/wideo)        │
└──────────┬──────────┘
           │
┌──────────▼──────────┐
│ Zamknięcie zadania  │
│ w GitLab            │
└─────────────────────┘
```

## 5. Obsługa uwierzytelniania

### 5.1. Metody uwierzytelniania

System obsługuje różne metody uwierzytelniania do zewnętrznych serwisów:

#### 5.1.1. Standardowe uwierzytelnianie (username/password)
- Przechowywanie poświadczeń w bezpiecznym magazynie (np. HashiCorp Vault)
- Automatyczne wypełnianie formularzy logowania

#### 5.1.2. Dwuskładnikowe uwierzytelnianie (2FA)
- SMS: Automatyczne odbieranie kodów przez podłączony moduł SMS
- Email: Monitorowanie skrzynki email i ekstrakcja kodów
- Aplikacje 2FA: Generowanie kodów lokalnie lub odczytywanie ich z aplikacji mobilnych

### 5.2. Przykładowa implementacja obsługi 2FA

```python
# Klasa do obsługi różnych metod 2FA
class TwoFactorAuthManager:
    def __init__(self):
        self.email_client = EmailClient()
        self.sms_client = SMSClient()
        self.totp_generator = TOTPGenerator()
        
    def get_auth_code(self, auth_type, identifier=None):
        """
        Pobiera kod autoryzacyjny z określonego źródła
        
        Args:
            auth_type: Typ autoryzacji ('email', 'sms', 'totp')
            identifier: Identyfikator dla danego typu (np. temat emaila, numer telefonu)
            
        Returns:
            str: Kod autoryzacyjny lub None w przypadku niepowodzenia
        """
        if auth_type == 'email':
            return self.get_code_from_email(identifier)
        elif auth_type == 'sms':
            return self.get_code_from_sms()
        elif auth_type == 'totp':
            return self.get_totp_code(identifier)
        else:
            return None
    
    def get_code_from_email(self, subject_pattern):
        """Pobiera kod 2FA z najnowszej wiadomości email pasującej do wzorca tematu"""
        emails = self.email_client.fetch_recent_emails(subject_pattern=subject_pattern, limit=1)
        if emails:
            return self.email_client.extract_code(emails[0])
        return None
    
    def get_code_from_sms(self):
        """Pobiera kod 2FA z najnowszego SMS"""
        messages = self.sms_client.fetch_recent_messages(limit=1)
        if messages:
            return self.sms_client.extract_code(messages[0])
        return None
    
    def get_totp_code(self, service_name):
        """Generuje kod TOTP dla danej usługi"""
        return self.totp_generator.generate_code(service_name)
```

## 6. Wdrożenie systemu

### 6.1. Wymagania sprzętowe

#### 6.1.1. Konfiguracja minimalna
- Procesor: 4 rdzenie CPU
- RAM: 16GB
- Dysk: 100GB SSD
- GPU: Zintegrowany (Intel Iris/AMD Radeon) lub Apple Silicon (Neural Engine)
- System operacyjny: Linux/macOS

#### 6.1.2. Konfiguracja zalecana
- Procesor: 8+ rdzeni CPU
- RAM: 32GB+
- Dysk: 500GB SSD
- GPU: NVIDIA RTX 4060+ lub Apple M2/M3/M4
- System operacyjny: Linux/macOS

### 6.2. Konfiguracja Docker Compose

Pełny plik docker-compose.yml dla wdrożenia systemu:

```yaml
version: '3.8'

services:
  # Ollama - lokalny LLM
  ollama:
    image: ollama/ollama:latest
    container_name: ollama
    ports:
      - "11434:11434"
    volumes:
      - ollama_data:/root/.ollama
    environment:
      - OLLAMA_HOST=0.0.0.0
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]
    restart: unless-stopped
  
  # Rozpoznawanie mowy (STT)
  stt:
    image: onerahmet/openai-whisper-asr-webservice:latest
    container_name: whisper
    ports:
      - "9000:9000"
    volumes:
      - ./whisper-data:/data
    environment:
      - ASR_MODEL=medium
    deploy:
      resources:
        reservations:
          devices:
            - driver: nvidia
              count: 1
              capabilities: [gpu]
    restart: unless-stopped
  
  # Synteza mowy (TTS)
  tts:
    image: synesthesiam/coqui-tts:latest
    container_name: tts
    ports:
      - "5002:5002"
    volumes:
      - ./tts-models:/app/voices
    restart: unless-stopped
  
  # GitLab CE
  gitlab:
    image: gitlab/gitlab-ce:latest
    container_name: gitlab
    ports:
      - "8080:80"
      - "8022:22"
    volumes:
      - gitlab_config:/etc/gitlab
      - gitlab_logs:/var/log/gitlab
      - gitlab_data:/var/opt/gitlab
    environment:
      GITLAB_OMNIBUS_CONFIG: |
        external_url 'http://localhost:8080'
        gitlab_rails['gitlab_shell_ssh_port'] = 8022
        gitlab_rails['time_zone'] = 'Europe/Warsaw'
    restart: unless-stopped
  
  # GitLab Runner
  gitlab-runner:
    image: gitlab/gitlab-runner:latest
    container_name: gitlab-runner
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - gitlab_runner_config:/etc/gitlab-runner
    restart: unless-stopped
    depends_on:
      - gitlab
  
  # Rocket.Chat
  rocketchat:
    image: rocketchat/rocket.chat:latest
    container_name: rocketchat
    ports:
      - "3000:3000"
    environment:
      - PORT=3000
      - ROOT_URL=http://localhost:3000
      - MONGO_URL=mongodb://mongo:27017/rocketchat
      - MONGO_OPLOG_URL=mongodb://mongo:27017/local
      - ENABLE_WEBRTC=true
      - WEBRTC_ENABLE_SCREEN_SHARING=true
    depends_on:
      - mongo
    restart: unless-stopped
  
  # MongoDB dla Rocket.Chat
  mongo:
    image: mongo:5.0
    container_name: mongo
    command: mongod --replSet rs0 --oplogSize 128
    volumes:
      - mongo_data:/data/db
    restart: unless-stopped
  
  # MongoDB Initializer
  mongo-init-replica:
    image: mongo:5.0
    restart: "no"
    depends_on:
      - mongo
    command: >
      bash -c "sleep 10 && mongosh --host mongo:27017 --eval 'rs.initiate({_id:\"rs0\",members:[{_id:0,host:\"mongo:27017\"}]})'"
  
  # Moduł automatyzacji przeglądarki
  browser-automation:
    build:
      context: ./browser-automation
      dockerfile: Dockerfile
    container_name: browser-automation
    volumes:
      - /tmp/.X11-unix:/tmp/.X11-unix
      - ./browser-automation:/app
    environment:
      - DISPLAY=:0
    restart: unless-stopped
  
  # VS Code Server
  code-server:
    image: linuxserver/code-server:latest
    container_name: code-server
    ports:
      - "8443:8443"
    volumes:
      - ./vscode-config:/config
      - ./workspace:/config/workspace
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Warsaw
      - PASSWORD=password123  # Zmień to w produkcji!
    restart: unless-stopped
  
  # Moduł Email Client (obsługa 2FA przez email)
  email-client:
    build:
      context: ./email-client
      dockerfile: Dockerfile
    container_name: email-client
    volumes:
      - ./email-data:/data
    environment:
      - EMAIL_SERVER=imap.example.com
      - EMAIL_USER=user@example.com
      - EMAIL_PASSWORD=your_secure_password
    restart: unless-stopped
  
  # SMS Gateway - obsługa 2FA przez SMS
  sms-gateway:
    image: jef/sms-gateway:latest
    container_name: sms-gateway
    ports:
      - "8090:8080"
    volumes:
      - ./sms-data:/data
    environment:
      - SMS_DEVICE_TOKEN=your_device_token
    restart: unless-stopped

volumes:
  ollama_data:
  gitlab_config:
  gitlab_logs:
  gitlab_data:
  gitlab_runner_config:
  mongo_data:
```

### 6.3. Terraform dla automatyzacji wdrożenia

Konfiguracja Terraform do automatyzacji wdrożenia systemu:

```hcl
# provider.tf
terraform {
  required_providers {
    docker = {
      source  = "kreuzwerker/docker"
      version = "~> 3.0.0"
    }
  }
}

provider "docker" {
  host = "unix:///var/run/docker.sock"
}

# variables.tf
variable "base_path" {
  description = "Bazowa ścieżka dla wolumenów"
  type        = string
  default     = "/opt/sepiw"
}

# main.tf
resource "docker_network" "sepiw_network" {
  name = "sepiw_network"
}

resource "docker_volume" "ollama_data" {
  name = "ollama_data"
}

resource "docker_volume" "gitlab_config" {
  name = "gitlab_config"
}

resource "docker_volume" "gitlab_logs" {
  name = "gitlab_logs"
}

resource "docker_volume" "gitlab_data" {
  name = "gitlab_data"
}

resource "docker_volume" "gitlab_runner_config" {
  name = "gitlab_runner_config"
}

resource "docker_volume" "mongo_data" {
  name = "mongo_data"
}

# Pozostałe zasoby podobne do konfiguracji docker-compose.yml
# ...

# output.tf
output "system_access" {
  value = <<EOF
System został pomyślnie wdrożony!

Dostęp do komponentów:
- Ollama API: http://localhost:11434
- GitLab: http://localhost:8080
- Rocket.Chat: http://localhost:3000
- VS Code Server: http://localhost:8443
- Whisper API (STT): http://localhost:9000
- TTS API: http://localhost:5002
- SMS Gateway: http://localhost:8090

Uwaga: Pamiętaj o zmianie domyślnych haseł przed użyciem w środowisku produkcyjnym.
EOF
}
```

## 7. Moduł automatyzacji pracy z przeglądarką

### 7.1. Dockerfile dla modułu automatyzacji

```dockerfile
FROM python:3.10-slim

# Instalacja zależności systemowych
RUN apt-get update && apt-get install -y \
    xvfb \
    x11vnc \
    firefox-esr \
    xauth \
    python3-tk \
    python3-dev \
    libx11-dev \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Instalacja bibliotek Python
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Kopiowanie kodu
COPY . .

# Skrypt startowy
COPY start.sh /start.sh
RUN chmod +x /start.sh

CMD ["/start.sh"]
```

### 7.2. Główny kod automatyzacji

```python
# browser_automation.py

import os
import time
import json
import requests
from selenium import webdriver
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import pyautogui
import cv2
import numpy as np
import threading
import logging

# Konfiguracja logowania
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class BrowserAutomation:
    def __init__(self):
        self.ollama_url = os.environ.get('OLLAMA_URL', 'http://ollama:11434')
        self.stt_url = os.environ.get('STT_URL', 'http://whisper:9000')
        self.tts_url = os.environ.get('TTS_URL', 'http://tts:5002')
        self.setup_browser()
        
    def setup_browser(self):
        """Konfiguracja przeglądarki Firefox z Selenium"""
        options = Options()
        options.add_argument("--headless")  # Usuń dla trybu widocznego
        options.add_argument("--window-size=1920,1080")
        self.driver = webdriver.Firefox(options=options)
        logger.info("Przeglądarka została zainicjowana")
        
    def navigate_to(self, url):
        """Nawigacja do określonego URL"""
        logger.info(f"Nawigacja do: {url}")
        self.driver.get(url)
        
    def wait_for_element(self, selector, timeout=10):
        """Oczekiwanie na element na stronie"""
        logger.info(f"Oczekiwanie na element: {selector}")
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((By.CSS_SELECTOR, selector))
            )
            return element
        except Exception as e:
            logger.error(f"Nie znaleziono elementu: {selector}, błąd: {str(e)}")
            return None
            
    def click_element(self, selector):
        """Kliknięcie elementu na stronie"""
        element = self.wait_for_element(selector)
        if element:
            logger.info(f"Kliknięcie elementu: {selector}")
            element.click()
            return True
        return False
        
    def input_text(self, selector, text):
        """Wprowadzenie tekstu do pola formularza"""
        element = self.wait_for_element(selector)
        if element:
            logger.info(f"Wprowadzenie tekstu do: {selector}")
            element.clear()
            element.send_keys(text)
            return True
        return False
        
    def take_screenshot(self, filename="screenshot.png"):
        """Wykonanie zrzutu ekranu"""
        logger.info(f"Wykonanie zrzutu ekranu: {filename}")
        self.driver.save_screenshot(filename)
        return filename
        
    def automate_vs_code(self, command):
        """Automatyzacja VS Code Web"""
        # Nawiguj do instancji VS Code Web
        self.navigate_to("http://code-server:8443")
        
        # Logowanie jeśli potrzebne
        if "Password" in self.driver.page_source:
            self.input_text("input[type='password']", os.environ.get('CODE_SERVER_PASSWORD', 'password123'))
            self.click_element("button[type='submit']")
            
        # Obsługa różnych komend VS Code
        if "open file" in command.lower():
            file_path = command.split("open file")[-1].strip()
            self.click_element(".explorer-viewlet")
            self.input_text(".search-input", file_path)
            time.sleep(1)
            self.click_element(".monaco-list-row")
            
        elif "create file" in command.lower():
            self.click_element(".explorer-viewlet")
            self.click_element("a[title='New File...']")
            file_name = command.split("create file")[-1].strip()
            self.input_text("input.monaco-inputbox", file_name)
            self.driver.find_element(By.CSS_SELECTOR, "input.monaco-inputbox").send_keys(webdriver.Keys.ENTER)
            
        elif "write code" in command.lower():
            code = command.split("write code")[-1].strip()
            editor = self.wait_for_element(".monaco-editor")
            if editor:
                editor.click()
                # Generowanie kodu przez Ollama
                generated_code = self.get_code_from_ollama(code)
                # Wpisywanie kodu do edytora
                editor.send_keys(generated_code)
                
        logger.info(f"Wykonano akcję VS Code: {command}")
        return self.take_screenshot("vscode_action.png")
        
    def get_code_from_ollama(self, prompt):
        """Pobieranie wygenerowanego kodu z Ollama"""
        try:
            response = requests.post(
                f"{self.ollama_url}/api/generate",
                json={
                    "model": "codellama",
                    "prompt": f"Generate code for: {prompt}",
                    "stream": False
                }
            )
            response_json = response.json()
            return response_json.get("response", "# Unable to generate code")
        except Exception as e:
            logger.error(f"Błąd przy generowaniu kodu: {str(e)}")
            return "# Error generating code"
            
    def login_to_service(self, url, username, password, auth_handlers=None):
        """Logowanie do serwisu z obsługą 2FA"""
        self.navigate_to(url)
        
        # Podstawowe logowanie
        self.input_text("input[name='username'], input[type='email'], input#username", username)
        self.input_text("input[name='password'], input[type='password'], input#password", password)
        self.click_element("button[type='submit'], input[type='submit'], .login-button")
        
        # Obsługa 2FA jeśli potrzebna
        if auth_handlers and ("code" in self.driver.page_source.lower() or "verification" in self.driver.page_source.lower()):
            logger.info("Wykryto 2FA, próba automatyzacji...")
            
            # Najpierw sprawdź SMS
            if "sms" in self.driver.page_source.lower() and "sms" in auth_handlers:
                logger.info("Próba pobrania kodu 2FA przez SMS")
                code = self.get_2fa_code("sms")
                if code:
                    self.input_text("input[name='code'], input#code, input.verification-code", code)
                    self.click_element("button[type='submit'], input[type='submit'], .verify-button")
                    
            # Następnie sprawdź email
            elif "email" in self.driver.page_source.lower() and "email" in auth_handlers:
                logger.info("Próba pobrania kodu 2FA przez email")
                code = self.get_2fa_code("email")
                if code:
                    self.input_text("input[name='code'], input#code, input.verification-code", code)
                    self.click_element("button[type='submit'], input[type='submit'], .verify-button")
            
            # Aplikacja TOTP
            elif "authenticator" in self.driver.page_source.lower() and "totp" in auth_handlers:
                logger.info("Próba pobrania kodu 2FA przez TOTP")
                code = self.get_2fa_code("totp", url)
                if code:
                    self.input_text("input[name='code'], input#code, input.verification-code", code)
                    self.click_element("button[type='submit'], input[type='submit'], .verify-button")
        
        logger.info(f"Zakończono proces logowania do {url}")
        return self.take_screenshot("login_result.png")
        
    def get_2fa_code(self, method, service=None):
        """Pobieranie kodu 2FA z różnych źródeł"""
        try:
            if method == "sms":
                response = requests.get("http://sms-gateway:8090/api/messages/latest")
                if response.status_code == 200:
                    message = response.json()
                    # Ekstrakcja kodu z wiadomości SMS - zazwyczaj 6 cyfr
                    import re
                    codes = re.findall(r'\b\d{6}\b', message.get("text", ""))
                    if codes:
                        return codes[0]
                        
            elif method == "email":
                response = requests.get("http://email-client:8080/api/emails/latest")
                if response.status_code == 200:
                    email = response.json()
                    # Ekstrakcja kodu z emaila - zazwyczaj 6 cyfr
                    import re
                    codes = re.findall(r'\b\d{6}\b', email.get("body", ""))
                    if codes:
                        return codes[0]
                        
            elif method == "totp" and service:
                response = requests.post(
                    "http://totp-generator:8070/api/generate", 
                    json={"service": service}
                )
                if response.status_code == 200:
                    return response.json().get("code")
                    
        except Exception as e:
            logger.error(f"Błąd przy pobieraniu kodu 2FA ({method}): {str(e)}")
            
        return None
        
    def close(self):
        """Zamknięcie przeglądarki"""
        self.driver.quit()
        logger.info("Przeglądarka została zamknięta")

# Główna klasa systemu łącząca wszystkie komponenty
class SEPIWSystem:
    def __init__(self):
        self.browser_automation = BrowserAutomation()
        self.running = True
        self.command_queue = []
        
    def start_command_listener(self):
        """Uruchomienie wątku nasłuchującego polecenia"""
        threading.Thread(target=self._command_listener, daemon=True).start()
        
    def _command_listener(self):
        """Wątek nasłuchujący polecenia od Ollama API"""
        while self.running:
            try:
                # Polling endpointu komend
                response = requests.get("http://api-gateway:8000/api/commands")
                if response.status_code == 200:
                    commands = response.json()
                    for command in commands:
                        self.command_queue.append(command)
                        logger.info(f"Dodano nowe polecenie do kolejki: {command['type']}")
                        
                # Oczekiwanie przed kolejnym odpytaniem
                time.sleep(5)
            except Exception as e:
                logger.error(f"Błąd w nasłuchiwaniu poleceń: {str(e)}")
                time.sleep(10)  # Dłuższe oczekiwanie po błędzie
                
    def process_commands(self):
        """Przetwarzanie poleceń z kolejki"""
        while self.running:
            if self.command_queue:
                command = self.command_queue.pop(0)
                self._execute_command(command)
            else:
                time.sleep(1)
                
    def _execute_command(self, command):
        """Wykonanie określonego polecenia"""
        command_type = command.get("type")
        command_data = command.get("data", {})
        
        logger.info(f"Wykonywanie polecenia: {command_type}")
        
        try:
            if command_type == "navigate":
                self.browser_automation.navigate_to(command_data.get("url"))
                
            elif command_type == "vs_code":
                self.browser_automation.automate_vs_code(command_data.get("command"))
                
            elif command_type == "login":
                self.browser_automation.login_to_service(
                    command_data.get("url"),
                    command_data.get("username"),
                    command_data.get("password"),
                    command_data.get("auth_handlers", [])
                )
                
            elif command_type == "gitlab_action":
                self._handle_gitlab_action(command_data)
                
            elif command_type == "rocket_chat_action":
                self._handle_rocket_chat_action(command_data)
                
            elif command_type == "screenshot":
                screenshot_path = self.browser_automation.take_screenshot(
                    command_data.get("filename", "screenshot.png")
                )
                # Powiadomienie o wykonaniu zrzutu ekranu
                self._notify_completion({
                    "type": "screenshot_completed",
                    "path": screenshot_path
                })
                
            else:
                logger.warning(f"Nieznany typ polecenia: {command_type}")
                
        except Exception as e:
            logger.error(f"Błąd podczas wykonywania polecenia {command_type}: {str(e)}")
            # Powiadomienie o błędzie
            self._notify_error({
                "type": "command_error",
                "command_type": command_type,
                "error": str(e)
            })
            
    def _handle_gitlab_action(self, data):
        """Obsługa akcji w GitLab"""
        action = data.get("action")
        
        if action == "create_project":
            # Logowanie do GitLab
            self.browser_automation.navigate_to("http://gitlab:8080")
            self.browser_automation.login_to_service(
                "http://gitlab:8080/users/sign_in",
                data.get("username"),
                data.get("password")
            )
            
            # Tworzenie projektu
            self.browser_automation.navigate_to("http://gitlab:8080/projects/new")
            self.browser_automation.input_text("#project_name", data.get("project_name"))
            self.browser_automation.input_text("#project_description", data.get("description", ""))
            self.browser_automation.click_element("input[type='submit'], .btn-confirm")
            
        elif action == "create_issue":
            # Nawigacja do strony projektu
            project_path = data.get("project_path")
            self.browser_automation.navigate_to(f"http://gitlab:8080/{project_path}/issues/new")
            
            # Wypełnienie formularza zgłoszenia
            self.browser_automation.input_text("#issue_title", data.get("title"))
            self.browser_automation.input_text("#issue_description", data.get("description", ""))
            self.browser_automation.click_element("input[type='submit'], .btn-confirm")
            
        elif action == "commit_code":
            # Nawigacja do edytora plików
            project_path = data.get("project_path")
            file_path = data.get("file_path")
            self.browser_automation.navigate_to(f"http://gitlab:8080/{project_path}/blob/master/{file_path}")
            
            # Kliknięcie przycisku edycji
            self.browser_automation.click_element(".js-edit-button")
            
            # Wprowadzenie kodu
            self.browser_automation.input_text(".monaco-editor", data.get("code"))
            
            # Wprowadzenie opisu commita
            self.browser_automation.input_text("#commit-message", data.get("commit_message", "Update code"))
            
            # Zatwierdzenie zmian
            self.browser_automation.click_element("input[type='submit'], .btn-confirm")
            
    def _handle_rocket_chat_action(self, data):
        """Obsługa akcji w Rocket.Chat"""
        action = data.get("action")
        
        if action == "send_message":
            # Logowanie do Rocket.Chat
            self.browser_automation.navigate_to("http://rocketchat:3000")
            self.browser_automation.login_to_service(
                "http://rocketchat:3000",
                data.get("username"),
                data.get("password")
            )
            
            # Nawigacja do kanału
            channel = data.get("channel")
            self.browser_automation.click_element(f"a[aria-label='{channel}']")
            
            # Wysłanie wiadomości
            self.browser_automation.input_text(".js-input-message", data.get("message"))
            self.browser_automation.click_element(".js-send")
            
        elif action == "start_video":
            # Nawigacja do kanału
            channel = data.get("channel")
            self.browser_automation.click_element(f"a[aria-label='{channel}']")
            
            # Rozpoczęcie transmisji wideo
            self.browser_automation.click_element(".video-button, .start-video-call")
            
            # Akceptacja uprawnień do kamery/mikrofonu jeśli potrzebne
            try:
                alert = self.browser_automation.driver.switch_to.alert
                alert.accept()
            except:
                pass
                
    def _notify_completion(self, data):
        """Powiadomienie o ukończeniu zadania"""
        try:
            requests.post("http://api-gateway:8000/api/notifications", json=data)
            logger.info(f"Wysłano powiadomienie o ukończeniu: {data['type']}")
        except Exception as e:
            logger.error(f"Błąd podczas wysyłania powiadomienia: {str(e)}")
            
    def _notify_error(self, data):
        """Powiadomienie o błędzie"""
        try:
            requests.post("http://api-gateway:8000/api/errors", json=data)
            logger.info(f"Wysłano powiadomienie o błędzie: {data['command_type']}")
        except Exception as e:
            logger.error(f"Błąd podczas wysyłania powiadomienia o błędzie: {str(e)}")
            
    def start(self):
        """Uruchomienie systemu"""
        logger.info("Uruchamianie systemu SEPIW...")
        self.start_command_listener()
        self.process_commands()
        
    def stop(self):
        """Zatrzymanie systemu"""
        logger.info("Zatrzymywanie systemu SEPIW...")
        self.running = False
        self.browser_automation.close()

# Uruchomienie systemu
if __name__ == "__main__":
    system = SEPIWSystem()
    try:
        system.start()
    except KeyboardInterrupt:
        system.stop()
    except Exception as e:
        logger.critical(f"Krytyczny błąd systemu: {str(e)}")
        system.stop()
```

## 8. Integracja z VS Code Web

### 8.1. Konfiguracja VS Code Server z wtyczkami

```yaml
# Fragment konfiguracji docker-compose.yml dla VS Code z wtyczkami
services:
  code-server:
    image: linuxserver/code-server:latest
    container_name: code-server
    ports:
      - "8443:8443"
    volumes:
      - ./vscode-config:/config
      - ./workspace:/config/workspace
    environment:
      - PUID=1000
      - PGID=1000
      - TZ=Europe/Warsaw
      - PASSWORD=password123  # Zmień to w produkcji!
    restart: unless-stopped
```

### 8.2. Instalacja wtyczek (skrypt)

```bash
#!/bin/bash
# install_extensions.sh

# Ścieżka do VS Code CLI
CODE_CLI=/config/code-server/bin/code-server

# Instalacja wtyczek
$CODE_CLI --install-extension continue.continue  # wtyczka Continue
$CODE_CLI --install-extension JoeyPGS.windsurfapp  # wtyczka Windsurf
$CODE_CLI --install-extension cursor.cursor  # wtyczka Cursor

# Konfiguracja dla integracji z Ollama
cat > /config/data/User/settings.json << EOF
{
    "continue.telemetry": false,
    "continue.modelTitle": "Ollama",
    "continue.completionModel": "ollama",
    "continue.systemContext": "You are a helpful assistant that helps with coding tasks",
    "continue.ollama.url": "http://ollama:11434",
    "continue.ollama.model": "codellama:code",
    "windsurfapp.connection.url": "http://ollama:11434",
    "windsurfapp.connection.model": "llama3",
    "cursor.developerMode": true,
    "cursor.projectModel": "ollama://<model>@ollama:11434",
    "cursor.modelPath": "ollama://<model>@ollama:11434"
}
EOF

echo "Wtyczki VS Code zostały zainstalowane i skonfigurowane"
```

## 9. Wdrożenie i testowanie

### 9.1. Instrukcja wdrożenia

1. Wymagania wstępne:
   - Docker i Docker Compose
   - Terraform (opcjonalnie)
   - NVIDIA Docker (dla GPU)

2. Kroki wdrożenia:
   
   a. Przygotowanie konfiguracji:
   ```bash
   mkdir -p /opt/sepiw
   cd /opt/sepiw
   git clone https://example.com/sepiw.git .
   ```
   
   b. Konfiguracja zmiennych środowiskowych:
   ```bash
   cp .env.example .env
   # Edytuj plik .env, aby skonfigurować hasła, tokeny API, itp.
   ```
   
   c. Wdrożenie z Docker Compose:
   ```bash
   docker-compose up -d
   ```
   
   lub z Terraform:
   ```bash
   terraform init
   terraform apply
   ```
   
   d. Weryfikacja wdrożenia:
   ```bash
   docker-compose ps
   ```

### 9.2. Testowanie systemu

1. Test komunikacji z Rocket.Chat:
   - Zaloguj się do Rocket.Chat (http://localhost:3000)
   - Utwórz kanał testowy
   - Wyślij wiadomość z zadaniem programistycznym

2. Test automatyzacji VS Code:
   - Zaloguj się do VS Code Server (http://localhost:8443)
   - Zweryfikuj, czy wtyczki są zainstalowane i skonfigurowane
   - Sprawdź, czy połączenie z Ollama działa prawidłowo

3. Test interakcji głosowej:
   - Uruchom nagrywanie głosu w Rocket.Chat
   - Wydaj polecenie głosowe dla systemu
   - Zweryfikuj, czy system poprawnie rozpoznaje i przetwarza polecenia

4. Test automatyzacji GitLab:
   - Zaloguj się do GitLab (http://localhost:8080)
   - Sprawdź, czy system może tworzyć projekty i commity

## 10. Bezpieczeństwo i uwagi końcowe

### 10.1. Bezpieczeństwo

1. Wszystkie hasła i tokeny powinny być przechowywane w bezpiecznym magazynie (np. HashiCorp Vault).
2. System działa lokalnie, co minimalizuje ryzyko wycieku danych.
3. Komunikacja między kontenerami powinna być zabezpieczona (wewnętrzna sieć Docker).
4. Regularna aktualizacja obrazów Docker w celu eliminacji podatności.
5. Ograniczenie dostępu do kontenerów tylko do niezbędnych portów.

### 10.2. Ograniczenia

1. System wymaga dostępu do przeglądarki i serwera X11 dla automatyzacji GUI.
2. Niektóre strony mogą mieć zabezpieczenia przed automatyzacją (np. CAPTCHA).
3. Wydajność LLM zależy od dostępnych zasobów sprzętowych.
4. Obsługa 2FA może wymagać dodatkowych komponentów sprzętowych (np. modem GSM dla SMS).

### 10.3. Rozwój systemu

1. Integracja z dodatkowymi narzędziami programistycznymi.
2. Wsparcie dla większej liczby języków programowania.
3. Rozszerzenie możliwości rozpoznawania obrazu i głosu.
4. Implementacja mechanizmów uczenia na podstawie interakcji z użytkownikiem.
5. Poprawa obsługi bardziej złożonych scenariuszy uwierzytelniania.