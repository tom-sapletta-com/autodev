
# Zoptymalizowany system automatyzacji programistycznej z wykorzystaniem CLI i API

## 1. Wprowadzenie

Na podstawie Twoich wymagań, przygotowałem zmodyfikowaną koncepcję systemu, który będzie wykorzystywał API i komendy CLI wszędzie tam, gdzie to możliwe, a interfejsy graficzne tylko wtedy, gdy jest to niezbędne. Szczególny nacisk położyłem na efektywne wykorzystanie wtyczek VS Code (Cursor/Windsurf/Cody/ChatGPT/Gemini) bezpośrednio przez CLI i API, aby zminimalizować koszty operacyjne i uzyskać lepszą wydajność.

## 2. Architektura systemu

### 2.1. Ogólna architektura

```
┌─────────────────────────────────────────────────────────────────┐
│                      Interfejs Użytkownika                       │
│  ┌───────────────┐   ┌───────────────┐   ┌───────────────────┐  │
│  │  Chat Tekstowy│   │  Chat Głosowy │   │  Transmisja Wideo │  │
│  └───────┬───────┘   └───────┬───────┘   └─────────┬─────────┘  │
└──────────┼───────────────────┼───────────────────┬─┘            │
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                         Rocket.Chat                            ││
│               (z rozszerzeniami wideo/audio)                   ││
└──────────┬───────────────────┬───────────────────┬─────────────┘│
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                      Moduł Middleware                          ││
│     (Obsługa komunikacji między komponentami systemu)          ││
└──────────┬───────────────────┬───────────────────┬─────────────┘│
           │                   │                   │              │
┌──────────▼──────┐  ┌─────────▼─────────┐ ┌───────▼────────────┐ │
│  Ollama (LLM)   │  │ CLI/API Manager   │ │  GitLab CLI/API    │ │
│                 │  │ (Wykonanie komend)│ │ (Zarządzanie kodem)│ │
└──────────┬──────┘  └─────────┬─────────┘ └───────┬────────────┘ │
           │                   │                   │              │
┌──────────▼───────────────────▼───────────────────▼─────────────┐│
│                                                               ││
│                VS Code Server + Wtyczki (CLI/API)              ││
│                (Cursor, Windsurf, Cody, ChatGPT)               ││
│                                                               ││
└───────────────────────────────────────────────────────────────┘│
```

### 2.2. Kluczowe komponenty systemu

1. **Ollama (Lokalny LLM)**
   - API-first - komunikacja wyłącznie przez REST API
   - Wykorzystanie gotowych modeli o rozmiarach 3B-34B w zależności od zadania
   - Synchronizacja z pozostałymi komponentami przez API

2. **VS Code Server (CLI/API)**
   - VS Code Server (code-server) z dostępem przez CLI/API
   - Instalacja i konfiguracja rozszerzeń przez CLI
   - Interakcje z edytorem przez API i komendy
   - Zdalne zarządzanie przez VS Code Remote API

3. **CLI/API Manager**
   - Centralne zarządzanie wywołaniami CLI i API
   - Obsługa uwierzytelniania (tokeny, OAuth, 2FA)
   - Rejestrowanie i monitorowanie komend
   - Obsługa błędów i ponawianie prób

4. **GitLab CLI/API**
   - Zarządzanie repozytoriami przez GitLab CLI (`glab`)
   - Tworzenie projektów, issue, MR przez API
   - Automatyzacja CI/CD przez GitLab API

5. **Rocket.Chat (Komunikacja)**
   - Obsługa wiadomości przez API Rocket.Chat
   - Webhook'i do raportowania postępów
   - Integracja z WebRTC do transmisji wideo

## 3. Konfiguracja VS Code Server i wtyczek

### 3.1. Instalacja VS Code Server

```bash
# Instalacja code-server
curl -fsSL https://code-server.dev/install.sh | sh

# Konfiguracja code-server
mkdir -p ~/.config/code-server
cat > ~/.config/code-server/config.yaml << EOF
bind-addr: 127.0.0.1:8080
auth: password
password: ${SECURE_PASSWORD}
cert: false
EOF

# Uruchomienie code-server jako usługi
systemctl --user enable --now code-server
```

### 3.2. Instalacja i konfiguracja wtyczek przez CLI

```bash
# Ścieżka do CLI code-server
CODE_SERVER_CLI="code-server --install-extension"

# Instalacja wtyczek przez CLI
$CODE_SERVER_CLI vscodevim.vim
$CODE_SERVER_CLI cursor.cursor
$CODE_SERVER_CLI JoeyPGS.windsurfapp 
$CODE_SERVER_CLI github.copilot
$CODE_SERVER_CLI github.copilot-chat
$CODE_SERVER_CLI continue.continue
$CODE_SERVER_CLI sourcegraph.cody
$CODE_SERVER_CLI GoogleCloudTools.cloudcode

# Konfiguracja wtyczki Cursor przez plik settings.json
mkdir -p ~/.local/share/code-server/User
cat > ~/.local/share/code-server/User/settings.json << EOF
{
  "cursor.developerMode": true,
  "cursor.projectModel": "ollama://llama3@ollama:11434",
  "cursor.modelPath": "ollama://llama3@ollama:11434",
  "windsurfapp.connection.url": "http://ollama:11434",
  "windsurfapp.connection.model": "llama3",
  "continue.modelTitle": "Ollama",
  "continue.completionModel": "ollama",
  "continue.ollama.url": "http://ollama:11434",
  "continue.ollama.model": "codellama:code",
  "github.copilot.enable": true
}
EOF
```

### 3.3. Automatyzacja VS Code przez CLI i API

```python
# Przykład automatyzacji VS Code przez CLI i API

import requests
import subprocess
import json
import os
import time

class VSCodeAutomation:
    def __init__(self, server_url="http://localhost:8080"):
        self.server_url = server_url
        self.session = requests.Session()
        # Autoryzacja w code-server
        self.auth_token = self._get_auth_token()
        
    def _get_auth_token(self):
        """Uzyskaj token uwierzytelniający do code-server"""
        # W praktyce można to zrobić przez scrapowanie sesji z plików cookie
        # lub przez API logowania, jeśli jest dostępne
        # To jest uproszczona implementacja
        return os.environ.get("CODE_SERVER_TOKEN", "")
        
    def execute_command(self, command_id, args=None):
        """Wykonaj komendę w VS Code przez REST API"""
        url = f"{self.server_url}/api/commands/{command_id}"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.auth_token}"
        }
        data = {"args": args} if args else {}
        response = self.session.post(url, headers=headers, json=data)
        return response.json()
        
    def open_file(self, file_path):
        """Otwórz plik w edytorze"""
        return self.execute_command("vscode.open", [file_path])
        
    def save_file(self):
        """Zapisz aktywny plik"""
        return self.execute_command("workbench.action.files.save")
        
    def execute_cli_command(self, command):
        """Wykonaj komendę CLI code-server"""
        result = subprocess.run(
            f"code-server {command}", 
            shell=True, 
            capture_output=True, 
            text=True
        )
        return result.stdout, result.stderr
        
    def use_extension_api(self, extension_id, endpoint, method="GET", data=None):
        """Wywołaj API rozszerzenia VS Code"""
        url = f"{self.server_url}/api/extensions/{extension_id}/{endpoint}"
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.auth_token}"
        }
        
        if method == "GET":
            response = self.session.get(url, headers=headers)
        elif method == "POST":
            response = self.session.post(url, headers=headers, json=data)
        elif method == "PUT":
            response = self.session.put(url, headers=headers, json=data)
        elif method == "DELETE":
            response = self.session.delete(url, headers=headers)
            
        return response.json()
        
    def generate_code_with_cursor(self, prompt):
        """Generuj kod używając rozszerzenia Cursor"""
        # Używanie API rozszerzenia Cursor (hipotetyczna implementacja)
        return self.use_extension_api(
            "cursor.cursor", 
            "generateCode", 
            method="POST",
            data={"prompt": prompt}
        )
        
    def generate_code_with_windsurf(self, prompt):
        """Generuj kod używając rozszerzenia Windsurf"""
        # Używanie API rozszerzenia Windsurf (hipotetyczna implementacja)
        return self.use_extension_api(
            "JoeyPGS.windsurfapp", 
            "generate", 
            method="POST",
            data={"prompt": prompt}
        )
        
    def trigger_intellisense(self):
        """Wywołaj IntelliSense w edytorze"""
        return self.execute_command("editor.action.triggerSuggest")
        
    def run_code_in_terminal(self):
        """Uruchom aktywny plik kodu w terminalu"""
        return self.execute_command("workbench.action.terminal.runActiveFile")
```

## 4. Automatyzacja GitLab przez CLI i API

### 4.1. Konfiguracja GitLab CLI (glab)

```bash
# Instalacja GitLab CLI
curl -s https://raw.githubusercontent.com/profclems/glab/trunk/scripts/install.sh | sudo bash

# Logowanie do GitLab
glab auth login --hostname your-gitlab-instance.com

# Tworzenie projektu
glab repo create my-project --description "Automatycznie utworzony projekt" --private
```

### 4.2. Automatyzacja GitLab przez API Python

```python
import requests
import os
import json

class GitLabAutomation:
    def __init__(self, gitlab_url, private_token):
        self.gitlab_url = gitlab_url
        self.headers = {"Private-Token": private_token}
        
    def create_project(self, name, description="", visibility="private"):
        """Utwórz nowy projekt GitLab"""
        url = f"{self.gitlab_url}/api/v4/projects"
        data = {
            "name": name,
            "description": description,
            "visibility": visibility
        }
        
        response = requests.post(url, headers=self.headers, json=data)
        return response.json()
        
    def create_issue(self, project_id, title, description=""):
        """Utwórz nowe zagadnienie w projekcie"""
        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/issues"
        data = {
            "title": title,
            "description": description
        }
        
        response = requests.post(url, headers=self.headers, json=data)
        return response.json()
        
    def create_merge_request(self, project_id, source_branch, target_branch, title, description=""):
        """Utwórz nowy merge request"""
        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/merge_requests"
        data = {
            "source_branch": source_branch,
            "target_branch": target_branch,
            "title": title,
            "description": description
        }
        
        response = requests.post(url, headers=self.headers, json=data)
        return response.json()
        
    def get_pipeline_status(self, project_id, pipeline_id):
        """Sprawdź status pipeline CI/CD"""
        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/pipelines/{pipeline_id}"
        response = requests.get(url, headers=self.headers)
        return response.json()
        
    def create_commit(self, project_id, branch, commit_message, actions):
        """Utwórz commit w repozytorium"""
        url = f"{self.gitlab_url}/api/v4/projects/{project_id}/repository/commits"
        data = {
            "branch": branch,
            "commit_message": commit_message,
            "actions": actions  # Lista zmian plików
        }
        
        response = requests.post(url, headers=self.headers, json=data)
        return response.json()
```

## 5. Integracja z Ollama przez API

### 5.1. Konfiguracja Ollama

```bash
# Instalacja Ollama
curl -fsSL https://ollama.com/install.sh | sh

# Uruchomienie Ollama z dostępem sieciowym
OLLAMA_HOST=0.0.0.0 ollama serve &

# Pobranie modeli
ollama pull llama3:7b
ollama pull codellama:7b
ollama pull llava:7b  # model wielomodalny tekst+obraz
```

### 5.2. Automatyzacja Ollama przez API

```python
import requests
import json
import base64
from PIL import Image
import io

class OllamaAutomation:
    def __init__(self, ollama_url="http://localhost:11434"):
        self.ollama_url = ollama_url
        
    def generate_text(self, prompt, model="llama3", stream=False):
        """Generuj tekst przez API Ollama"""
        url = f"{self.ollama_url}/api/generate"
        data = {
            "model": model,
            "prompt": prompt,
            "stream": stream
        }
        
        response = requests.post(url, json=data)
        return response.json()
        
    def generate_code(self, prompt, model="codellama:7b"):
        """Generuj kod przez API Ollama z modelem CodeLlama"""
        return self.generate_text(
            f"Write code for the following task: {prompt}",
            model=model
        )
        
    def analyze_image(self, image_path, prompt, model="llava:7b"):
        """Analizuj obraz przez API Ollama z modelem multimodalnym"""
        # Konwersja obrazu do base64
        with open(image_path, "rb") as img_file:
            img_data = base64.b64encode(img_file.read()).decode('utf-8')
            
        url = f"{self.ollama_url}/api/generate"
        data = {
            "model": model,
            "prompt": prompt,
            "images": [img_data]
        }
        
        response = requests.post(url, json=data)
        return response.json()
        
    def list_models(self):
        """Pobierz listę dostępnych modeli Ollama"""
        url = f"{self.ollama_url}/api/tags"
        response = requests.get(url)
        return response.json()
        
    def get_model_info(self, model_name):
        """Pobierz informacje o modelu"""
        url = f"{self.ollama_url}/api/show"
        data = {
            "name": model_name
        }
        
        response = requests.post(url, json=data)
        return response.json()
```

## 6. Obsługa uwierzytelniania 2FA

### 6.1. Automatyczne pobieranie kodów 2FA

```python
import imaplib
import email
import re
import time

class AuthenticationManager:
    def __init__(self):
        self.email_client = None
        self.sms_client = None
        
    def setup_email_client(self, email_server, email_address, password):
        """Konfiguracja klienta email do pobierania kodów 2FA"""
        self.email_client = imaplib.IMAP4_SSL(email_server)
        self.email_client.login(email_address, password)
        
    def get_code_from_email(self, subject_pattern, sender=None, max_age_minutes=5):
        """Pobieranie kodu 2FA z najnowszego emaila"""
        if not self.email_client:
            raise Exception("Email client not configured")
            
        self.email_client.select('INBOX')
        
        # Tworzenie kryteriów wyszukiwania
        search_criteria = []
        if sender:
            search_criteria.append(f'FROM "{sender}"')
        if subject_pattern:
            search_criteria.append(f'SUBJECT "{subject_pattern}"')
            
        # Pobieranie tylko nowych wiadomości
        since_date = (time.time() - (max_age_minutes * 60))
        search_criteria.append(f'SINCE {time.strftime("%d-%b-%Y", time.localtime(since_date))}')
        
        search_string = ' '.join(search_criteria)
        result, data = self.email_client.search(None, search_string)
        
        if result != 'OK' or not data or not data[0]:
            return None
            
        # Pobranie najnowszej wiadomości
        latest_email_id = data[0].split()[-1]
        result, message_data = self.email_client.fetch(latest_email_id, '(RFC822)')
        
        if result != 'OK':
            return None
            
        # Parsowanie wiadomości
        raw_email = message_data[0][1]
        email_message = email.message_from_bytes(raw_email)
        
        # Wyodrębnienie treści
        body = ""
        if email_message.is_multipart():
            for part in email_message.walk():
                content_type = part.get_content_type()
                if content_type == "text/plain" or content_type == "text/html":
                    try:
                        body += part.get_payload(decode=True).decode()
                    except:
                        pass
        else:
            body = email_message.get_payload(decode=True).decode()
            
        # Znalezienie kodu 2FA - szukanie 4-8 cyfrowego kodu
        code_match = re.search(r'\b\d{4,8}\b', body)
        if code_match:
            return code_match.group(0)
            
        return None
        
    def setup_sms_client(self, api_key, phone_number):
        """Konfiguracja klienta SMS do pobierania kodów 2FA - przykładowa implementacja"""
        # W rzeczywistej implementacji należałoby użyć konkretnego API SMS
        self.sms_client = {
            "api_key": api_key,
            "phone_number": phone_number
        }
        
    def get_code_from_sms(self, sender=None, max_age_minutes=5):
        """Pobieranie kodu 2FA z najnowszego SMS"""
        if not self.sms_client:
            raise Exception("SMS client not configured")
            
        # Przykładowa implementacja - w rzeczywistości należałoby użyć konkretnego API SMS
        # Tutaj możnaby użyć np. Twilio, Nexmo lub lokalnego serwera SMS
        
        # Symulacja pobrania SMS
        sms_text = "Your verification code is 123456. Do not share it with anyone."
        
        # Znalezienie kodu 2FA - szukanie 4-8 cyfrowego kodu
        code_match = re.search(r'\b\d{4,8}\b', sms_text)
        if code_match:
            return code_match.group(0)
            
        return None
        
    def generate_totp_code(self, secret):
        """Generowanie kodu TOTP dla 2FA opartego o aplikacje"""
        import pyotp
        
        totp = pyotp.TOTP(secret)
        return totp.now()
```

## 7. Automatyzacja GUI tylko gdy konieczne (fallback)

### 7.1. Kiedy używać automatyzacji GUI

W niektórych przypadkach konieczne będzie użycie automatyzacji GUI, zwłaszcza gdy:

1. **Wtyczka nie oferuje API** - niektóre wtyczki VS Code nie mają publicznego API ani możliwości uruchomienia przez CLI
2. **Interaktywna autoryzacja** - niektóre serwisy wymagają interaktywnego logowania CAPTCHA lub OAuth z przekierowaniem
3. **Prezentacja wideo** - generowanie prezentacji wideo postępów dla klienta

### 7.2. Automatyzacja GUI przy użyciu PyAutoGUI i Selenium

```python
import pyautogui
import time
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

class GUIAutomation:
    def __init__(self):
        self.browser = None
        
    def setup_browser(self, headless=False):
        """Konfiguracja przeglądarki do automatyzacji"""
        chrome_options = Options()
        if headless:
            chrome_options.add_argument("--headless")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        
        self.browser = webdriver.Chrome(options=chrome_options)
        
    def navigate_to(self, url):
        """Nawigacja do wskazanego URL"""
        if not self.browser:
            self.setup_browser()
        self.browser.get(url)
        
    def click_element(self, selector, timeout=10):
        """Kliknięcie elementu na stronie"""
        try:
            element = WebDriverWait(self.browser, timeout).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
            )
            element.click()
            return True
        except Exception as e:
            print(f"Error clicking element {selector}: {str(e)}")
            return False
            
    def input_text(self, selector, text, timeout=10):
        """Wprowadzenie tekstu do formularza"""
        try:
            element = WebDriverWait(self.browser, timeout).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, selector))
            )
            element.clear()
            element.send_keys(text)
            return True
        except Exception as e:
            print(f"Error inputting text to {selector}: {str(e)}")
            return False
            
    def take_screenshot(self, filename="screenshot.png"):
        """Wykonanie zrzutu ekranu"""
        if not self.browser:
            return None
        self.browser.save_screenshot(filename)
        return filename
        
    def record_video(self, duration_seconds=30, output_file="recording.mp4"):
        """Nagrywanie krótkiego wideo do celów demonstracyjnych"""
        import cv2
        import numpy as np
        
        # Konfiguracja nagrywania
        screen_size = pyautogui.size()
        fourcc = cv2.VideoWriter_fourcc(*'mp4v')
        fps = 10.0
        
        # Inicjalizacja nagrywania
        video = cv2.VideoWriter(output_file, fourcc, fps, screen_size)
        
        # Nagrywanie ekranu
        start_time = time.time()
        while (time.time() - start_time) < duration_seconds:
            # Przechwycenie ekranu
            img = pyautogui.screenshot()
            frame = np.array(img)
            # Konwersja kolorów (BGR jest używany przez OpenCV)
            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)
            # Zapisanie klatki do wideo
            video.write(frame)
            # Opóźnienie dla utrzymania FPS
            time.sleep(1.0/fps)
            
        # Zakończenie nagrywania
        video.release()
        return output_file
```

## 8. Integracja z komunikatorem Rocket.Chat

### 8.1. Konfiguracja Rocket.Chat

```bash
# Wdrożenie Rocket.Chat przez Docker Compose
cat > docker-compose.yml << EOF
version: '3'

services:
  mongo:
    image: mongo:5.0
    volumes:
      - ./data/mongo:/data/db
    command: mongod --oplogSize 128
    restart: unless-stopped

  rocketchat:
    image: rocketchat/rocket.chat:latest
    command: >
      bash -c
        "for i in `seq 1 30`; do
          node main.js &&
          s=$$? && break || s=$$?;
          echo \"Tried $$i times. Waiting 5 secs...\";
          sleep 5;
        done; (exit $$s)"
    restart: unless-stopped
    volumes:
      - ./uploads:/app/uploads
    environment:
      - PORT=3000
      - ROOT_URL=http://localhost:3000
      - MONGO_URL=mongodb://mongo:27017/rocketchat
      - MONGO_OPLOG_URL=mongodb://mongo:27017/local
      - MAIL_URL=smtp://smtp.email
      - OVERWRITE_SETTING_Show_Setup_Wizard=completed
      - ADMIN_USERNAME=admin
      - ADMIN_PASS=password
      - ADMIN_EMAIL=admin@example.com
    depends_on:
      - mongo
    ports:
      - 3000:3000
EOF

# Uruchomienie Rocket.Chat
docker-compose up -d
```

### 8.2. Automatyzacja Rocket.Chat przez API

```python
import requests
import json

class RocketChatAutomation:
    def __init__(self, server_url, username, password):
        self.server_url = server_url
        self.username = username
        self.password = password
        self.auth_token = None
        self.user_id = None
        self.login()
        
    def login(self):
        """Logowanie do Rocket.Chat przez API"""
        url = f"{self.server_url}/api/v1/login"
        data = {
            "username": self.username,
            "password": self.password
        }
        
        response = requests.post(url, json=data)
        result = response.json()
        
        if response.status_code == 200 and result.get('status') == 'success':
            self.auth_token = result['data']['authToken']
            self.user_id = result['data']['userId']
            return True
        else:
            raise Exception(f"Login failed: {result.get('message')}")
            
    def get_headers(self):
        """Zwróć nagłówki autoryzacyjne"""
        return {
            "X-Auth-Token": self.auth_token,
            "X-User-Id": self.user_id,
            "Content-Type": "application/json"
        }
        
    def send_message(self, room_id, text):
        """Wysłanie wiadomości na kanał"""
        url = f"{self.server_url}/api/v1/chat.postMessage"
        data = {
            "roomId": room_id,
            "text": text
        }
        
        response = requests.post(url, headers=self.get_headers(), json=data)
        return response.json()
        
    def create_channel(self, name, members=None, private=False):
        """Utworzenie nowego kanału"""
        if private:
            url = f"{self.server_url}/api/v1/groups.create"
        else:
            url = f"{self.server_url}/api/v1/channels.create"
            
        data = {
            "name": name
        }
        
        if members:
            data["members"] = members
            
        response = requests.post(url, headers=self.get_headers(), json=data)
        return response.json()
        
    def upload_file(self, room_id, file_path, description=None):
        """Wgranie pliku na kanał"""
        url = f"{self.server_url}/api/v1/rooms.upload/{room_id}"
        
        with open(file_path, 'rb') as file:
            files = {
                'file': file
            }
            
            data = {}
            if description:
                data['description'] = description
                
            response = requests.post(
                url, 
                headers={
                    "X-Auth-Token": self.auth_token,
                    "X-User-Id": self.user_id
                },
                data=data,
                files=files
            )
            
        return response.json()
        
    def start_video_call(self, room_id):
        """Inicjacja połączenia wideo"""
        url = f"{self.server_url}/api/v1/video-conference/jitsi.update-timeout"
        data = {
            "roomId": room_id
        }
        
        response = requests.post(url, headers=self.get_headers(), json=data)
        return response.json()
```

## 9. Autonomiczna warstwa funkcjonalna dla Ollama 

### 9.1. Architektura autonomicznej warstwy

Aby umożliwić Ollamie samodzielne dodawanie nowych funkcji i rozbudowywanie możliwości systemu bez uszkodzenia istniejącej funkcjonalności, zaprojektowałem warstwę autonomiczną działającą w modelu piaskownicy (sandbox).

```
┌────────────────────────────────────────────────────────────────┐
│                     Główny System Produkcyjny                  │
└───────────────┬────────────────────────────────┬───────────────┘
                │                                │
                ▼                                ▼
┌───────────────────────────┐      ┌───────────────────────────┐
│   Ollama API Gateway      │      │   Rejestr Funkcji         │
│   (kontrola dostępu)      │◄────►│   (metadane, wersje)      │
└───────────────┬───────────┘      └───────────────┬───────────┘
                │                                  │
                ▼                                  ▼
┌───────────────────────────┐      ┌───────────────────────────┐
│  Piaskownica Ollama       │      │  System Kontroli Wersji   │
│  (izolowane środowisko)   │◄────►│  (git, testy, CI/CD)      │
└───────────────┬───────────┘      └───────────────────────────┘
                │                    
                ▼                    
┌───────────────────────────┐      ┌───────────────────────────┐
│  Generator Funkcji        │      │  System Testów            │
│  (kod, dokumentacja)      │◄────►│  (auto-testy, walidacja)  │
└───────────────────────────┘      └───────────────────────────┘
```

### 9.2. Implementacja piaskownicy dla Ollama

```python
import os
import subprocess
import importlib.util
import sys
import json
import uuid
import time
import docker
import git
import pytest
from typing import Dict, List, Any, Callable

class OllamaFunctionRegistry:
    """Rejestr funkcji tworzonych przez Ollama"""
    
    def __init__(self, registry_path: str = "~/.ollama/functions"):
        self.registry_path = os.path.expanduser(registry_path)
        os.makedirs(self.registry_path, exist_ok=True)
        self.registry_file = os.path.join(self.registry_path, "registry.json")
        self.functions = self._load_registry()
        
    def _load_registry(self) -> Dict:
        """Ładowanie rejestru funkcji z pliku"""
        if os.path.exists(self.registry_file):
            with open(self.registry_file, 'r') as f:
                return json.load(f)
        return {"functions": {}, "version": "1.0"}
        
    def _save_registry(self):
        """Zapisanie rejestru funkcji do pliku"""
        with open(self.registry_file, 'w') as f:
            json.dump(self.functions, f, indent=2)
            
    def register_function(self, name: str, description: str, version: str, 
                         file_path: str, function_name: str, 
                         signature: Dict, examples: List[Dict] = None) -> str:
        """Rejestracja nowej funkcji stworzonej przez Ollama"""
        function_id = str(uuid.uuid4())
        
        self.functions["functions"][function_id] = {
            "name": name,
            "description": description,
            "version": version,
            "file_path": file_path,
            "function_name": function_name,
            "signature": signature,
            "examples": examples or [],
            "created_at": time.time(),
            "updated_at": time.time(),
            "status": "testing",  # testing, approved, production
            "test_results": None
        }
        
        self._save_registry()
        return function_id
        
    def update_function_status(self, function_id: str, status: str, test_results: Dict = None):
        """Aktualizacja statusu funkcji po testach"""
        if function_id not in self.functions["functions"]:
            raise ValueError(f"Function with ID {function_id} not found")
            
        self.functions["functions"][function_id]["status"] = status
        self.functions["functions"][function_id]["updated_at"] = time.time()
        
        if test_results:
            self.functions["functions"][function_id]["test_results"] = test_results
            
        self._save_registry()
        
    def get_function(self, function_id: str) -> Dict:
        """Pobranie informacji o funkcji"""
        if function_id not in self.functions["functions"]:
            raise ValueError(f"Function with ID {function_id} not found")
            
        return self.functions["functions"][function_id]
        
    def list_functions(self, status: str = None) -> List[Dict]:
        """Listowanie dostępnych funkcji z możliwością filtrowania po statusie"""
        result = []
        
        for function_id, function_data in self.functions["functions"].items():
            if status is None or function_data["status"] == status:
                func_info = function_data.copy()
                func_info["id"] = function_id
                result.append(func_info)
                
        return result
        
    def load_function(self, function_id: str) -> Callable:
        """Dynamiczne ładowanie funkcji z pliku"""
        function_info = self.get_function(function_id)
        
        module_path = function_info["file_path"]
        function_name = function_info["function_name"]
        
        spec = importlib.util.spec_from_file_location("dynamic_module", module_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        
        if not hasattr(module, function_name):
            raise ValueError(f"Function {function_name} not found in module {module_path}")
            
        return getattr(module, function_name)


class OllamaSandbox:
    """Piaskownica dla funkcji generowanych przez Ollama"""
    
    def __init__(self, ollama_url: str, registry: OllamaFunctionRegistry, 
                 sandbox_path: str = "~/.ollama/sandbox"):
        self.ollama_url = ollama_url
        self.registry = registry
        self.sandbox_path = os.path.expanduser(sandbox_path)
        os.makedirs(self.sandbox_path, exist_ok=True)
        self.docker_client = docker.from_env()
        
    def generate_function(self, task_description: str, requirements: List[str] = None) -> str:
        """Generowanie nowej funkcji na podstawie opisu zadania"""
        # Przygotowanie folderu na nową funkcję
        function_dir = os.path.join(self.sandbox_path, f"func_{int(time.time())}")
        os.makedirs(function_dir, exist_ok=True)
        
        # Inicjalizacja repozytorium git
        repo = git.Repo.init(function_dir)
        
        # Generowanie kodu funkcji przez Ollama
        function_code = self._generate_code(task_description, requirements)
        
        # Zapisanie kodu do pliku
        function_file = os.path.join(function_dir, "function.py")
        with open(function_file, 'w') as f:
            f.write(function_code["code"])
            
        # Generowanie testów jednostkowych
        test_code = self._generate_tests(function_code["code"], task_description)
        
        # Zapisanie testów do pliku
        test_file = os.path.join(function_dir, "test_function.py")
        with open(test_file, 'w') as f:
            f.write(test_code)
            
        # Commit zmian do git
        repo.git.add(A=True)
        repo.index.commit("Initial function generation")
        
        # Rejestracja funkcji
        function_id = self.registry.register_function(
            name=function_code["name"],
            description=function_code["description"],
            version="0.1.0",
            file_path=function_file,
            function_name=function_code["function_name"],
            signature=function_code["signature"],
            examples=function_code["examples"]
        )
        
        # Testowanie funkcji
        test_results = self.test_function(function_id)
        
        # Aktualizacja statusu funkcji na podstawie wyników testów
        if test_results["success"]:
            self.registry.update_function_status(function_id, "approved", test_results)
        else:
            self.registry.update_function_status(function_id, "testing", test_results)
            
        return function_id
        
    def _generate_code(self, task_description: str, requirements: List[str] = None) -> Dict:
        """Generowanie kodu funkcji przez Ollama"""
        # Przygotowanie promptu dla Ollama
        prompt = f"""
        Wygeneruj nową funkcję Python na podstawie poniższego opisu:
        
        Zadanie: {task_description}
        
        {"Wymagania: " + ", ".join(requirements) if requirements else ""}
        
        Proszę zwróć kod w następującym formacie JSON:
        {{
            "name": "nazwa_funkcji",
            "description": "szczegółowy opis funkcji",
            "function_name": "nazwa_funkcji_w_pythonie",
            "code": "pełny kod funkcji z komentarzami i docstringami",
            "signature": {{
                "parameters": [
                    {{"name": "param1", "type": "typ_parametru", "description": "opis parametru"}},
                    ...
                ],
                "return": {{"type": "typ_zwracany", "description": "opis zwracanej wartości"}}
            }},
            "examples": [
                {{"input": {{...}}, "output": "..."}},
                ...
            ]
        }}
        """
        
        # Wywołanie Ollama API
        import requests
        response = requests.post(
            f"{self.ollama_url}/api/generate",
            json={"model": "codellama:7b", "prompt": prompt, "stream": False}
        )
        
        # Parsowanie odpowiedzi
        result = response.json()
        
        # Ekstrakcja JSON z odpowiedzi
        import re
        json_match = re.search(r'```(?:json)?\s*({.*?})\s*```', result["response"], re.DOTALL)
        
        if json_match:
            function_data = json.loads(json_match.group(1))
        else:
            try:
                function_data = json.loads(result["response"])
            except:
                raise ValueError("Failed to parse function data from Ollama response")
                
        return function_data
        
    def _generate_tests(self, function_code: str, task_description: str) -> str:
        """Generowanie testów jednostkowych przez Ollama"""
        # Przygotowanie promptu dla Ollama
        prompt = f"""
        Wygeneruj testy jednostkowe pytest dla poniższej funkcji:
        
        ```python
        {function_code}
        ```
        
        Zadanie funkcji: {task_description}
        
        Testy powinny sprawdzać poprawność działania funkcji, obsługę brzegowych przypadków oraz wyjątków.
        """
        
        # Wywołanie Ollama API
        import requests
        response = requests.post(
            f"{self.ollama_url}/api/generate",
            json={"model": "codellama:7b", "prompt": prompt, "stream": False}
        )
        
        # Parsowanie odpowiedzi
        result = response.json()
        
        # Ekstrakcja kodu testów z odpowiedzi
        import re
        code_match = re.search(r'```(?:python)?\s*(.*?)```', result["response"], re.DOTALL)
        
        if code_match:
            test_code = code_match.group(1)
        else:
            test_code = result["response"]
            
        return test_code
        
    def test_function(self, function_id: str) -> Dict:
        """Testowanie funkcji w izolowanym środowisku"""
        function_info = self.registry.get_function(function_id)
        
        # Przygotowanie środowiska testowego
        test_dir = os.path.dirname(function_info["file_path"])
        
        try:
            # Uruchomienie testów w kontenerze Docker
            container = self.docker_client.containers.run(
                "python:3.9-slim",
                f"cd /app && pip install pytest && python -m pytest test_function.py -v",
                volumes={test_dir: {"bind": "/app", "mode": "ro"}},
                detach=True
            )
            
            # Pobranie wyniku testów
            result = container.wait()
            logs = container.logs().decode('utf-8')
            
            # Czyszczenie
            container.remove()
            
            # Sprawdzenie wyniku testów
            success = result["StatusCode"] == 0
            
            return {
                "success": success,
                "logs": logs,
                "exit_code": result["StatusCode"]
            }
            
        except Exception as e:
            # W przypadku błędu w testach
            return {
                "success": False,
                "logs": str(e),
                "exit_code": -1
            }
            
    def deploy_function(self, function_id: str) -> bool:
        """Wdrożenie funkcji do środowiska produkcyjnego"""
        function_info = self.registry.get_function(function_id)
        
        # Sprawdzenie czy funkcja przeszła testy
        if function_info["status"] != "approved":
            raise ValueError(f"Function {function_id} is not approved for deployment")
            
        try:
            # Przygotowanie do wdrożenia
            module_path = function_info["file_path"]
            function_name = function_info["function_name"]
            
            # Kopiowanie funkcji do katalogu produkcyjnego
            production_dir = os.path.expanduser("~/.ollama/production")
            os.makedirs(production_dir, exist_ok=True)
            
            target_file = os.path.join(production_dir, f"{function_name}.py")
            
            # Kopiowanie pliku
            import shutil
            shutil.copy2(module_path, target_file)
            
            # Aktualizacja statusu funkcji
            self.registry.update_function_status(function_id, "production")
            
            return True
            
        except Exception as e:
            print(f"Deployment failed: {str(e)}")
            return False
            
    def rollback_function(self, function_id: str) -> bool:
        """Wycofanie funkcji z produkcji"""
        function_info = self.registry.get_function(function_id)
        
        if function_info["status"] != "production":
            return True  # Nie ma potrzeby wycofywania
            
        try:
            # Usunięcie funkcji z produkcji
            function_name = function_info["function_name"]
            production_file = os.path.expanduser(f"~/.ollama/production/{function_name}.py")
            
            if os.path.exists(production_file):
                os.remove(production_file)
                
            # Aktualizacja statusu funkcji
            self.registry.update_function_status(function_id, "approved")
            
            return True
            
        except Exception as e:
            print(f"Rollback failed: {str(e)}")
            return False


class OllamaFunctionManager:
    """Zarządzanie funkcjami generowanymi przez Ollama"""
    
    def __init__(self, ollama_url: str = "http://localhost:11434"):
        self.ollama_url = ollama_url
        self.registry = OllamaFunctionRegistry()
        self.sandbox = OllamaSandbox(ollama_url, self.registry)
        
    def create_function(self, task_description: str, requirements: List[str] = None) -> str:
        """Tworzenie nowej funkcji na podstawie opisu zadania"""
        return self.sandbox.generate_function(task_description, requirements)
        
    def get_available_functions(self, include_testing: bool = False) -> List[Dict]:
        """Pobieranie listy dostępnych funkcji"""
        if include_testing:
            return self.registry.list_functions()
        else:
            # Tylko funkcje zatwierdzone lub produkcyjne
            approved = self.registry.list_functions(status="approved")
            production = self.registry.list_functions(status="production")
            return approved + production
            
    def execute_function(self, function_id: str, *args, **kwargs) -> Any:
        """Wykonanie funkcji na podstawie ID"""
        function_info = self.registry.get_function(function_id)
        
        if function_info["status"] == "testing":
            raise ValueError(f"Function {function_id} is in testing status and cannot be executed")
            
        # Ładowanie funkcji
        function = self.registry.load_function(function_id)
        
        # Wykonanie funkcji
        return function(*args, **kwargs)
        
    def deploy_function(self, function_id: str) -> bool:
        """Wdrożenie funkcji do środowiska produkcyjnego"""
        return self.sandbox.deploy_function(function_id)
        
    def rollback_function(self, function_id: str) -> bool:
        """Wycofanie funkcji z produkcji"""
        return self.sandbox.rollback_function(function_id)
        
    def get_function_details(self, function_id: str) -> Dict:
        """Pobieranie szczegółów funkcji"""
        return self.registry.get_function(function_id)


class OllamaAutonomousLayer:
    """Warstwa autonomiczna dla Ollama"""
    
    def __init__(self, ollama_url: str = "http://localhost:11434"):
        self.ollama_url = ollama_url
        self.function_manager = OllamaFunctionManager(ollama_url)
        self.function_cache = {}
        
    def execute_task(self, task_description: str, *args, **kwargs) -> Any:
        """Wykonanie zadania - automatyczne generowanie funkcji jeśli konieczne"""
        # Sprawdzenie czy istnieje funkcja do realizacji zadania
        existing_functions = self.function_manager.get_available_functions()
        suitable_function = self._find_suitable_function(existing_functions, task_description)
        
        if suitable_function:
            # Użycie istniejącej funkcji
            return self.function_manager.execute_function(suitable_function["id"], *args, **kwargs)
        else:
            # Generowanie nowej funkcji
            print(f"Generowanie nowej funkcji dla zadania: {task_description}")
            function_id = self.function_manager.create_function(task_description)
            
            # Sprawdzenie czy funkcja została zatwierdzona
            function_details = self.function_manager.get_function_details(function_id)
            
            if function_details["status"] in ["approved", "production"]:
                # Wdrożenie funkcji do produkcji
                self.function_manager.deploy_function(function_id)
                
                # Wykonanie nowej funkcji
                return self.function_manager.execute_function(function_id, *args, **kwargs)
            else:
                raise ValueError(f"Failed to create function for task: {task_description}")
                
    def _find_suitable_function(self, functions: List[Dict], task_description: str) -> Dict:
        """Znalezienie odpowiedniej funkcji do wykonania zadania"""
        import re
        from difflib import SequenceMatcher
        
        best_match = None
        best_score = 0.6  # Minimalny próg podobieństwa
        
        for function in functions:
            # Porównanie opisów funkcji z opisem zadania
            similarity = SequenceMatcher(None, function["description"].lower(), 
                                        task_description.lower()).ratio()
            
            # Sprawdzenie kluczowych słów
            task_keywords = set(re.findall(r'\b\w+\b', task_description.lower()))
            desc_keywords = set(re.findall(r'\b\w+\b', function["description"].lower()))
            
            keyword_overlap = len(task_keywords.intersection(desc_keywords)) / len(task_keywords) if task_keywords else 0
            
            # Kombinacja metryk
            score = 0.6 * similarity + 0.4 * keyword_overlap
            
            if score > best_score:
                best_score = score
                best_match = function
                
        return best_match
        
    def enhance_function(self, function_id: str, improvement_description: str) -> str:
        """Ulepszenie istniejącej funkcji"""
        function_details = self.function_manager.get_function_details(function_id)
        
        # Przygotowanie opisu zadania
        task_description = f"""
        Ulepsz następującą funkcję:
        
        Nazwa: {function_details['name']}
        Opis: {function_details['description']}
        
        Wymagane ulepszenia:
        {improvement_description}
        """
        
        # Generowanie nowej wersji funkcji
        new_function_id = self.function_manager.create_function(task_description)
        
        return new_function_id
```

### 9.3. Przykład użycia autonomicznej warstwy Ollama

```python
# Przykładowy kod demonstrujący wykorzystanie autonomicznej warstwy Ollama

def demo_autonomous_ollama():
    # Inicjalizacja warstwy autonomicznej
    autonomous_layer = OllamaAutonomousLayer()
    
    # Przykładowe zadanie, które nie jest jeszcze zaimplementowane
    task_description = "Pobieranie i analiza najnowszych danych pogodowych dla podanej lokalizacji"
    
    try:
        # Wykonanie zadania - automatyczne generowanie funkcji jeśli konieczne
        result = autonomous_layer.execute_task(
            task_description,
            location="Gdansk,PL",
            metrics=["temperature", "humidity", "wind_speed"],
            forecast_days=5
        )
        
        print(f"Wynik zadania: {result}")
        
        # Pobranie listy dostępnych funkcji
        available_functions = autonomous_layer.function_manager.get_available_functions()
        print(f"Dostępne funkcje: {len(available_functions)}")
        
        # Pobranie szczegółów wygenerowanej funkcji
        if available_functions:
            function_id = available_functions[-1]["id"]
            function_details = autonomous_layer.function_manager.get_function_details(function_id)
            
            print(f"Szczegóły funkcji:")
            print(f"- Nazwa: {function_details['name']}")
            print(f"- Opis: {function_details['description']}")
            print(f"- Status: {function_details['status']}")
            
            # Ulepszenie funkcji
            improvement_description = "Dodaj możliwość porównania danych pogodowych z historycznymi średnimi"
            new_function_id = autonomous_layer.enhance_function(function_id, improvement_description)
            
            print(f"Utworzono ulepszoną funkcję o ID: {new_function_id}")
            
    except Exception as e:
        print(f"Błąd: {str(e)}")

if __name__ == "__main__":
    demo_autonomous_ollama()
```

## 10. Podsumowanie

Przedstawiona warstwa autonomiczna dla Ollama umożliwia:

1. **Samodzielne tworzenie nowych funkcji** - Ollama może autonomicznie generować kod do realizacji zadań, które wcześniej nie były zaimplementowane.

2. **Bezpieczne testowanie** - Wszystkie nowe funkcje są testowane w izolowanym środowisku (piaskownicy) przed wdrożeniem do produkcji.

3. **Wersjonowanie i zarządzanie** - Każda funkcja jest rejestrowana, wersjonowana i zarządzana, co umożliwia łatwe wycofanie zmian.

4. **Ciągłe doskonalenie** - System umożliwia ulepszanie istniejących funkcji w miarę nabywania nowej wiedzy.

5. **Automatyczne dopasowanie** - Ollama próbuje najpierw znaleźć odpowiednią istniejącą funkcję, a jeśli takiej nie ma, tworzy nową.

Ta architektura pozwala Ollamie autonomicznie rozwijać możliwości systemu w sposób kontrolowany i bezpieczny, bez ingerencji człowieka w już działające komponenty.

Cały system jest zoptymalizowany do działania poprzez CLI i API, minimalizując użycie interfejsów graficznych i wykorzystując maksymalnie możliwości dostępnych narzędzi programistycznych.